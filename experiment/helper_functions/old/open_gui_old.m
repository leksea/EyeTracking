function [dat,scr] = open_gui
%
% gui for loading and setting motion in depth experiment
 
   [dat,scr] = default;

   %GUI SET UP%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   %  Create and then hide the GUI as it is being constructed.
   screen           = get(0,'ScreenSize'); %left, bottom, width, height (1,1 = bottom left)
   buffer           = 30; %padding on gui sides
   im_display_size  = 18; %pixel width of disparity maps and images generated by default
   screen_resize    = [screen(1) + 0.1*screen(3),screen(2) + 0.1*screen(4),0.9*screen(3),0.9*screen(4)]; %make a little smaller than full screen
   im_plot_size     = screen_resize(3)/5; %size of plots in gui
   
   f = figure('Visible','off','Position',screen_resize);
   
   %image toggles
   im1_low_contrast     = 0;
   im2_low_contrast     = 0;
   disp1_low_range   = 0;
   disp2_low_range   = 0;
   show_response_map = 0;

   %COMMON TO ALL MODELS:
   %set disparity tuning function peak locations
   gabor_modeling   = 0;
   disp_lim         = 40;           % Maximum disparity value coded by neurons, arcmin
   disp_step        = 0.25;           %disparity step between adjacent tunings, arcmin
   disparities      = -disp_lim : disp_step : disp_lim;
   
   % Set disparity limits and steps for tuning evaluation
   disp_axis_lim    = 60;                      
   disp_axis_step   = 0.1;
   disparity_axis   = -disp_axis_lim : disp_axis_step : disp_axis_lim;
   disparity_axis   = round(10.*disparity_axis)./10; %some rounding is needed
   disparity_range  = disp_axis_lim; %disparity maps cover full range
   
   % Definition of the width of the individual neuron tuning function
   min_width        = 2;
   max_width        = 150;
   
   % Set contrast limits and steps for tuning evaluation
   contrast_lim     = 1; % (lum - meanlum)/(lum+meanlum)
   contrast_step    = 0.1;
   contrasts        = -contrast_lim : contrast_step : contrast_lim;
   
   tuning_contrast_slice = 0; %slice of tunings to displays across one contrast, initially
   numcells              = 15; %number to cells to plot tuning functions of
   %downsample cells evenly for plotting
   zval         = find(disparities == 0);
   cells_tmp    = 0:round(length(disparities)/numcells):floor(length(disparities)/2);
   cells        = zval + [fliplr(-cells_tmp(2:end)) cells_tmp];
   
   %all disparities and contrasts to evaluate
   [disparities_all,contrasts_all] = meshgrid(disparities,contrasts);
   
   %initialize images
   im1 = zeros(im_display_size,im_display_size);
   im2 = zeros(im_display_size,im_display_size);
   disp1 = zeros(im_display_size,im_display_size);
   disp2 = zeros(im_display_size,im_display_size);
   
   
   %initialize and create disparity/luminance tuning models
   response_all = [];
   
   %generic models
   model1_disparity_tunings = [];
   model1_disparity_maxs = [];
   model1_disparity_maxamps = [];
   model2_disparity_tunings = [];
   model2_disparity_maxs = [];
   model2_disparity_maxamps = [];
   
   %specific models
   bc_model_disparity_tunings = [];
   bc_model_disparity_maxs = [];
   bc_model_disparity_maxamps = [];
   
   uni_model_disparity_tunings = [];
   uni_model_disparity_maxs = [];
   uni_model_disparity_maxamps = [];
   
   cs_model_disparity_tunings = [];
   cs_model_disparity_maxs = [];
   cs_model_disparity_maxamps = [];
   
   make_disparity_models;
      
   
   % Initialize the GUI.
   make_image_axes;
   make_model_axes;
   make_population_axes;
   make_image_toggles;
   make_update_response_button;
   set([im1popup, im2popup, disp1popup, disp2popup, im1ax, im2ax, disp1ax, disp2ax, model1ax, model2ax, ...
       model1sliceax, model2sliceax,popax,modelcont_slider_title,modelcont_slider,...
       model1popup,model2popup,im1contrastradio,im2contrastradio,disp1rangeradio,disp2rangeradio,updatebutton],'Units','normalized'); % Change units to normalized so components resize automatically.
   initialize_images;
   draw_lines;
   
   set(f,'Name','Disparity/Luminance population model') % Assign the GUI a name to appear in the window title.
   movegui(f,'center') % Move the GUI to the center of the screen.
   set(f,'Visible','on'); % Make the GUI visible.
 
   %CALLBACKS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %  Callbacks for simple_gui. These callbacks automatically
   %  have access to component handles and initialized data 
   %  because they are nested at a lower level.
 
   %  Pop-up menu callback. Read the pop-up menu Value property
   %  to determine which item is currently displayed and make it
   %  the current data.
  
    function popup_menu_Callback_im1(source,eventdata)
        
        [im1,im1_low_contrast] = im_switch(source);
        image_show('image 1',im1ax,im1);
        set(im1contrastradio,'Value',0);
        %update_population_responses;
        
    end
  
    function popup_menu_Callback_im2(source,eventdata)
        
        [im2,im2_low_contrast] = im_switch(source);
        image_show('image 2',im2ax,im2);
        set(im2contrastradio,'Value',0);
        %update_population_responses;
        
    end

    function popup_menu_Callback_disp1(source,eventdata)

        [disp1,disp1_low_range] = disp_switch(source);
        disparity_show('disparity 1',disp1ax,disp1);
        set(disp1rangeradio,'Value',0);
        %update_population_responses;
        
    end

    function popup_menu_Callback_disp2(source,eventdata)
        
        [disp2,disp2_low_range] = disp_switch(source);
        disparity_show('disparity 2',disp2ax,disp2);
        set(disp2rangeradio,'Value',0);
        %update_population_responses;
        
    end

    function popup_menu_Callback_model1(source,eventdata)

        [model1_disparity_tunings, model1_disparity_maxs, model1_disparity_maxamps] = model_switch(source);
        model_show('model 1',model1ax,model1_disparity_maxamps)
        tunings_show(model1sliceax,model1_disparity_tunings)
        %update_population_responses;
        
    end
  
    function popup_menu_Callback_model2(source,eventdata)

        [model2_disparity_tunings, model2_disparity_maxs, model2_disparity_maxamps] = model_switch(source);
        model_show('model 2',model2ax,model2_disparity_maxamps)
        tunings_show(model2sliceax,model2_disparity_tunings)
        %update_population_responses;
        
    end

    function slider_Callback_model_contrast(source,eventdata)
        
        tuning_contrast_slice = get(source,'Value');
        model_show('model 1',model1ax,model1_disparity_maxamps);
        tunings_show(model1sliceax,model1_disparity_tunings)
        model_show('model 2',model2ax,model2_disparity_maxamps);
        tunings_show(model2sliceax,model2_disparity_tunings)
    end

    function toggle_Callback_im1_contrast(source,eventdata)
        
        im1_low_contrast = get(source,'Value');
        if im1_low_contrast
            im1 = 0.25 + (im1.*0.5); %cut range in half
        else
            im1 = (im1 - min(im1(:))).*2; %restore full range
        end
        image_show('image 1',im1ax,im1);
        %update_population_responses;
    end

    function toggle_Callback_im2_contrast(source,eventdata)
        
        im2_low_contrast = get(source,'Value');
        if im2_low_contrast
            im2 = 0.25 + (im2.*0.5); %cut range in half
        else
            im2 = (im2 - min(im2(:))).*2; %restore full range
        end
        image_show('image 2',im2ax,im2);
        %update_population_responses;
    end

    function toggle_Callback_disp1_range(source,eventdata)
        
        disp1_low_range = get(source,'Value');
        if disp1_low_range
            disp1 = disp1.*0.25; %cut range in half
        else
            disp1 = disp1.*4; %restore full range
        end
        disparity_show('disparity 1',disp1ax,disp1);
        %update_population_responses;
    end

    function toggle_Callback_disp2_range(source,eventdata)
        
        disp2_low_range = get(source,'Value');
        if disp2_low_range
            disp2 = disp2.*0.25; %cut range in half
        else
            disp2 = disp2.*4; %restore full range
        end
        disparity_show('disparity 2',disp2ax,disp2);
        %update_population_responses;
    end

    function updatebutton_Callback(source,eventdata)
        
        update_population_responses;
    end

    function toggle_Callback_show_response_map(source,eventdata)
        show_response_map = get(source,'Value');
    end

    %CASE STATEMENTS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    function [im,im_low_contrast] = im_switch(source)
        % Determine the selected data set.
        str = get(source, 'String');
        val = get(source,'Value');
        switch str{val};
            case 'zero'
                im = zeros(im_display_size,im_display_size);
            case 'uniform noise'
                im = rand(im_display_size,im_display_size);   
            case 'bottom = bright'
                im = repmat(linspace(0,1,im_display_size)',1,im_display_size);   
            case 'bottom = dark'
                im = repmat(linspace(1,0,im_display_size)',1,im_display_size); 
            case 'object = bright'
                im = zeros(im_display_size,im_display_size);
                %make circle object
                r = im_display_size/4;
                [x,y] = meshgrid(-(im_display_size/2-1):(im_display_size-im_display_size/2),-(im_display_size/2-1):(im_display_size-im_display_size/2));
                
                im((x.^2+y.^2)<=r^2) = 1;
                
            case 'object = dark'
                im = ones(im_display_size,im_display_size);
                %make circle object
                r = im_display_size/4;
                [x,y] = meshgrid(-(im_display_size/2-1):(im_display_size-im_display_size/2),-(im_display_size/2-1):(im_display_size-im_display_size/2));
                
                im((x.^2+y.^2)<=r^2) = 0;  
            case 'mb_wood2'
                im = imresize(rgb2gray(imread('../SonyStereo/testimages/mb_wood2/mb_wood2right.png')),[im_display_size im_display_size]);
        end
        im_low_contrast = 0;
    end

    function [disp,disp_low_range] = disp_switch(source)
        str = get(source, 'String');
        val = get(source,'Value');
        % Set current data to the selected data set.
        switch str{val};
            case 'zero' % User selects Peaks.
                disp = zeros(im_display_size,im_display_size);
            case 'uniform noise' % User selects Membrane.
                disp = round(10.*((2.*disp_axis_lim.*rand(im_display_size,im_display_size)) - disp_axis_lim))./10;
            case 'bottom = near'
                disp = round(10.*repmat(linspace(disp_axis_lim,-disp_axis_lim,im_display_size)',1,im_display_size))./10;
            case 'bottom = far'
                disp = round(10.*repmat(linspace(-disp_axis_lim,disp_axis_lim,im_display_size)',1,im_display_size))./10;
            case 'near object'
                disp = disp_axis_lim.*ones(im_display_size,im_display_size);
                %make circle object
                r = im_display_size/4;
                [x,y] = meshgrid(-(im_display_size/2-1):(im_display_size-im_display_size/2),-(im_display_size/2-1):(im_display_size-im_display_size/2));
                
                disp((x.^2+y.^2)<=r^2) = -disp_axis_lim;
                
        end
        disp_low_range = 0;
    end

    function [model_disparity_tunings, model_disparity_maxs, model_disparity_maxamps] = model_switch(source)
        str = get(source, 'String');
        val = get(source,'Value');
        % Set current data to the selected data set.
        switch str{val};
            case 'cottereau' % User selects Peaks.
                model_disparity_tunings = bc_model_disparity_tunings;
                model_disparity_maxs = bc_model_disparity_maxs;
                model_disparity_maxamps = bc_model_disparity_maxamps;
            case 'uniform' % User selects Membrane.
                model_disparity_tunings = uni_model_disparity_tunings;
                model_disparity_maxs = uni_model_disparity_maxs;
                model_disparity_maxamps = uni_model_disparity_maxamps;
            case 'dmd simple' % User selects Membrane.
                model_disparity_tunings = cs_model_disparity_tunings;
                model_disparity_maxs = cs_model_disparity_maxs;
                model_disparity_maxamps = cs_model_disparity_maxamps;
        end
    end

    function image_show(imtitle,imax,im)
        axes(imax);
        imshow(im); title(imtitle,'Units','normalized','Position', [1 1], 'HorizontalAlignment', 'right')
    end

    function disparity_show(disptitle,dispax,disp)
        axes(dispax);
        imagesc(-disp,[-disp_axis_lim disp_axis_lim]); title(disptitle,'Units','normalized','Position', [1 1], 'HorizontalAlignment', 'right')
        set(gca, 'XTick', [],'YTick',[]);
        axis image; box on; dcb = colorbar;
        ylabel(dcb,'disparity - neg = crossed (arcmin)');
        ylim(dcb,[-disp_axis_lim disp_axis_lim]);
        set(dcb,'YtickLabel',{'60', '40', '20', '0', '-20', '-40', '-60'})

    end
        
    function model_show(mtitle,modelax,model_disparity_maxamps)
        
        axes(modelax);
        surf(disparities_all,contrasts_all,model_disparity_maxamps, 'EdgeColor', 'none'); hold on;
        
        colors = jet(numcells);
        for c = 1:length(cells)
            plot3(disparities(cells(c)),[tuning_contrast_slice],[100],'Color',colors(c,:),'Marker','o')
        end
        %plot3([min(disparities_all(:)) max(disparities_all(:))],[tuning_contrast_slice tuning_contrast_slice],[100 100],'r--')
        title(mtitle);
        xlabel('peak disparity (arc min)');
        ylabel('contrast');
        view(2); 
        cb = colorbar;
        caxis([0 1]);
        ylabel(cb,'peak amplitude');
        ylim(cb,[0 1]);
        hold off;
    end

    function tunings_show(modelsliceax,model_disparity_tunings)
        
        axes(modelsliceax); 
        delta = abs(contrasts_all(:,1) - tuning_contrast_slice);
        line_ind = max(find(delta == min(delta)));
        %line_ind = find(contrasts_all(:,1) == tuning_contrast_slice);
        plot_tunings = model_disparity_tunings(line_ind,:,:);
        allcells = size(plot_tunings,2);
        
        colors = jet(numcells);
        for t = 1:length(cells);
            
            plot( disparity_axis' , squeeze(plot_tunings(:,cells(t),:)) , 'Color', colors(t,:) , 'LineWidth' , 1 ); hold on;
            
        end
        axis([-disp_axis_lim disp_axis_lim -0.2 1.1])
        %xlabel('disparity (arcmin)');
        text(-disp_axis_lim + 1,1,'example tuning functions');
        hold off;
        
    end


    function make_image_axes
        
        im1popup = uicontrol('Style','popupmenu',...
            'String',{'zero','uniform noise','bottom = bright','bottom = dark','object = bright','object = dark','mb_wood2'},...
            'Position',[buffer,screen_resize(4) - buffer,175,25],...
            'Callback',{@popup_menu_Callback_im1});
        im2popup = uicontrol('Style','popupmenu',...
            'String',{'zero','uniform noise','bottom = bright','bottom = dark','object = bright','object = dark','mb_wood2'},...
            'Position',[buffer + screen_resize(3)/2,screen_resize(4) - buffer,175,25],...
            'Callback',{@popup_menu_Callback_im2});
        disp1popup = uicontrol('Style','popupmenu',...
            'String',{'zero','uniform noise','bottom = near','bottom = far','near object'},...
            'Position',[buffer + screen_resize(3)/4 - 1.8*buffer,screen_resize(4) - buffer,175,25],...
            'Callback',{@popup_menu_Callback_disp1});
        disp2popup = uicontrol('Style','popupmenu',...
            'String',{'zero','uniform noise','bottom = near','bottom = far','near object'},...
            'Position',[buffer + screen_resize(3)/2 + im_plot_size + buffer/2,screen_resize(4) - buffer,175,25],...
            'Callback',{@popup_menu_Callback_disp2});
        
        im1ax = axes('Units','Pixels','Position',[buffer,screen_resize(4) - buffer - im_plot_size,im_plot_size,im_plot_size]);
        axis image; box on;
        set(gca,'xtick',[],'ytick',[]); title('image 1','Units','normalized','Position', [1 1], 'HorizontalAlignment', 'right');
        
        disp1ax = axes('Units','Pixels','Position',[buffer + 10,screen_resize(4) - buffer - im_plot_size,im_plot_size*1.2,im_plot_size]);
        axis image; box on;
        set(gca,'xtick',[],'ytick',[]); title('disparity 1','Units','normalized','Position', [1 1], 'HorizontalAlignment', 'right');
        
        im2ax = axes('Units','Pixels','Position',[buffer + 20,screen_resize(4) - buffer - im_plot_size,im_plot_size,im_plot_size]);
        axis image; box on;
        set(gca,'xtick',[],'ytick',[]); title('image 2','Units','normalized','Position', [1 1], 'HorizontalAlignment', 'right');
        
        disp2ax = axes('Units','Pixels','Position',[screen_resize(3) - buffer - 1.2*im_plot_size,screen_resize(4) - buffer - im_plot_size,im_plot_size*1.2,im_plot_size]);
        axis image; box on;
        set(gca,'xtick',[],'ytick',[]); title('disparity 2','Units','normalized','Position', [1 1], 'HorizontalAlignment', 'right');
        
        align([im1ax,disp1ax,im2ax,disp2ax],'Distribute','Top');
        set(disp1ax,'Position',get(disp1ax,'Position') - [buffer/2 0 0 0]);
        set(im2ax,'Position',get(im2ax,'Position') + [buffer/2 0 0 0]);
        
    end

    function make_model_axes
        
        model1popup = uicontrol('Style','popupmenu',...
            'String',{'cottereau','uniform','dmd simple'},...
            'Position',[buffer,screen_resize(4) - buffer - 1.2*im_plot_size,100,25],...
            'Callback',{@popup_menu_Callback_model1});
        model2popup = uicontrol('Style','popupmenu',...
            'String',{'cottereau','uniform','dmd simple'},...
            'Position',[screen_resize(3) - im_plot_size - buffer - 20,screen_resize(4) - buffer - 1.2*im_plot_size,100,25],...
            'Callback',{@popup_menu_Callback_model2});
        
        modelcont_slider_title = uicontrol('Style','text',...
            'Position', [screen_resize(3)/2 - im_plot_size/2,screen_resize(4) - buffer - 2.75*im_plot_size,100,40],...
            'string','contrast level for tuning function <-visuals->');
        modelcont_slider = uicontrol('Style','slider',...
            'Min',min(contrasts_all(:)),'Max',max(contrasts_all(:)),'Value',0,...
            'SliderStep',[1/(length(unique(contrasts_all(:)))-1) 1/length(unique(contrasts_all(:)))],...
            'Position', [screen_resize(3)/2 - im_plot_size/2,screen_resize(4) - buffer - 3*im_plot_size,im_plot_size,im_plot_size/4],...
            'Callback', {@slider_Callback_model_contrast});
        
        model1ax = axes('Units','Pixels','Position',[buffer + 20,screen_resize(4) - buffer - 2.2*im_plot_size,im_plot_size,im_plot_size]);
        axis image; box on;
        title('model 1');
        
        model1sliceax = axes('Units','Pixels','Position',[buffer + 20,screen_resize(4) - buffer - 2.9*im_plot_size,im_plot_size,im_plot_size/2]);
        box on;
        %title('model 1');
        
        model2ax = axes('Units','Pixels','Position',[screen_resize(3) - im_plot_size - buffer, screen_resize(4) - buffer - 2.2*im_plot_size,im_plot_size,im_plot_size]);
        axis image; box on;
        title('model 2');

        model2sliceax = axes('Units','Pixels','Position',[screen_resize(3) - im_plot_size - buffer,screen_resize(4) - buffer - 2.9*im_plot_size,im_plot_size,im_plot_size/2]);
        box on;
        %title('model 1');
        
        align([model1ax,model2ax],'None','Top');
        align([modelcont_slider_title,modelcont_slider],'Center','None');
    end

    function make_update_response_button
        updatebutton = uicontrol('Style','pushbutton','String','UPDATE',...
          'Position',[screen_resize(3)/2 - 25,screen_resize(2) + buffer,50,50],...
          'Callback',{@updatebutton_Callback});
      
        showrespmapradio = uicontrol('Style', 'radiobutton', ...
                           'Callback', @toggle_Callback_show_response_map, ...
                           'Units',    'pixels', ...
                           'Position', [screen_resize(3)/2 + 30,screen_resize(2) + buffer + 25,200,30], ...
                           'String',   'SHOW RESPONSE MAP', ...
                           'Value',    0);
    end

    function make_population_axes
        
        popax = axes('Units','Pixels','Position',...
            [screen_resize(3)/2 - im_plot_size,screen_resize(4) - buffer - 2.2*im_plot_size im_plot_size*2 im_plot_size]);
        box on;
        title('population responses');
        
    end

    function make_image_toggles
        
        im1contrastradio = uicontrol('Style', 'radiobutton', ...
                           'Callback', @toggle_Callback_im1_contrast, ...
                           'Units',    'pixels', ...
                           'Position', [buffer, screen_resize(4) - im_plot_size - buffer - 20, 100, 22], ...
                           'String',   'lower contrast', ...
                           'Value',    0);
                       
        im2contrastradio = uicontrol('Style', 'radiobutton', ...
                           'Callback', @toggle_Callback_im2_contrast, ...
                           'Units',    'pixels', ...
                           'Position', get(im2ax,'Position') + [0 -20 -(im_plot_size-100) -(im_plot_size-22)], ...
                           'String',   'lower contrast', ...
                           'Value',    0);      
        disp1rangeradio = uicontrol('Style', 'radiobutton', ...
                           'Callback', @toggle_Callback_disp1_range, ...
                           'Units',    'pixels', ...
                           'Position', get(disp1ax,'Position') + [0 -20 -(im_plot_size-80) -(im_plot_size-22)], ...
                           'String',   'lower range', ...
                           'Value',    0);
                       
        disp2rangeradio = uicontrol('Style', 'radiobutton', ...
                           'Callback', @toggle_Callback_disp2_range, ...
                           'Units',    'pixels', ...
                           'Position', get(disp2ax,'Position') + [0 -20 -(im_plot_size-80) -(im_plot_size-22)], ...
                           'String',   'lower range', ...
                           'Value',    0);                
    end

    function initialize_images
        
        image_show('image 1',im1ax,im1);
        image_show('image 2',im2ax,im2);
        disparity_show('disparity 1',disp1ax,disp1);
        disparity_show('disparity 2',disp2ax,disp2);
        
        %initialize models
        model1_disparity_tunings = bc_model_disparity_tunings;
        model1_disparity_maxs = bc_model_disparity_maxs;
        model1_disparity_maxamps = bc_model_disparity_maxamps;
        
        model2_disparity_tunings = bc_model_disparity_tunings;
        model2_disparity_maxs = bc_model_disparity_maxs;
        model2_disparity_maxamps = bc_model_disparity_maxamps;
        
        model_show('model 1',model1ax,model1_disparity_maxamps)
        model_show('model 2',model2ax,model2_disparity_maxamps)
        
        tunings_show(model1sliceax,model1_disparity_tunings)
        tunings_show(model2sliceax,model1_disparity_tunings)
        
        update_population_responses;
        
    end

    function draw_lines
        a = axes;
        set(a, 'Visible', 'off');
        %# Stretch the axes over the whole figure.
        set(a, 'Position', [0, 0, 1, 1]);
        %# Switch off autoscaling.
        set(a, 'Xlim', [0, 1], 'YLim', [0, 1]);

        %# Draw!
        hold on;
        plot([.005 .005], [.005 0.995], 'r')
        plot([.005 .27], [.005 0.005], 'r')
        plot([.27 .27], [.005 0.615], 'r')
        plot([.005 .495], [.995 0.995], 'r')
        plot([.495 .495], [.995 0.615], 'r')
        plot([.27 .495], [.615 0.615], 'r')
        
        plot([.995 .995], [.005 0.995], 'b--')
        plot([.995 .73], [.005 0.005], 'b--')
        plot([.73 .73], [.005 0.615], 'b--')
        plot([.995 .505], [.995 0.995], 'b--')
        plot([.505 .505], [.995 0.615], 'b--')
        plot([.73 .505], [.615 0.615], 'b--') 
        
        hold off

    end
    function make_disparity_models
        
        
        %TUNING FUNCTION WIDTHS
        % (1) The receptive field widths are uniform across the different disparity values
        width_law       = max_width / 10 * ones( size(disparities_all) );
        
        % (2) tuning width changes for disparity-size correlation :Bigger receptive fields are needed to represent bigger disparity values
        width_law_tmp            = sqrt( min_width ) : ( sqrt( max_width ) - sqrt( min_width ) ) / ...
                                        ( disp_lim / disp_step - 1 ) :  sqrt( max_width );
        width_law_ds_correlation = [ fliplr(width_law_tmp) sqrt( min_width ) width_law_tmp ];
        width_law_ds_correlation = repmat(width_law_ds_correlation,length(contrasts),1);
        
        
        %CROSSED/UNCROSSED BIAS
        % Bias between the crossed and uncrossed populations for each luminance value
        % (1) no bias
        bias_no_bias = ones(size(disparities_all));
        
        % (2) bias for crossed disparities across all luminances
        bias_cross              = 1;
        bias_uncross            = 0.5;
        bias_cross_unc_all_bias = ( max( bias_cross , bias_uncross ) - min( bias_cross , bias_uncross ) ) * ...
            ( 1 + exp( .1 * sign(bias_cross - bias_uncross) * disparities_all ) ) .^(-1) + min( bias_cross , bias_uncross );
        
        % (3) bias switches from crossed to incrossed for positive and
        % negative contrasts
        bias_cross_unc_brighter_bias = bias_cross_unc_all_bias;
        bias_uncross_cr_darker_bias  = fliplr(bias_cross_unc_all_bias);
        bias_contrast_simple         = cat(1,bias_uncross_cr_darker_bias(1:floor(size(disparities_all,1)/2),:), ...
                                           bias_cross_unc_brighter_bias(floor(size(disparities_all,1)/2) + 1:end,:));
        %NUMBER OF CELLS
        % Number of cells tuned to each disparity/luminance combo
        %(1) the same for all disparities
        cell_number_same = ones( size(disparities_all) );
        
        %decreasing at largger disparities
        decrease_start  = 10;    % At this disparity value, the number of neurons start to decrease
        cell_number_dec = ones( size(disparities_all) );
        for i = 1 : numel( cell_number_dec )
            if abs( disparities_all( i ) ) > decrease_start
                cell_number_dec( i ) = cell_number_same( i ) .* ( 1 + disp_lim - abs( disparities_all( i ) ) ) ./ ( 1 + disp_lim - decrease_start );
            end
        end
        
        
        %BUILD TUNING MODELS
        %MODEL 1: Cottereau paper: crossed > uncrossed bias, with disparity-size correlation, with more cells at small disparities
        [bc_model_disparity_tunings,bc_model_disparity_maxs,bc_model_disparity_maxamps] = ...
            make_model_responses(width_law_ds_correlation,bias_cross_unc_all_bias,cell_number_dec);
        %MODEL 2: Uniform: No bias, no disparity-size correlation, same number of cells at all disparities
        [uni_model_disparity_tunings,uni_model_disparity_maxs,uni_model_disparity_maxamps] = ...
            make_model_responses(width_law,bias_no_bias,cell_number_same);
        %MODEL 3: Simple contrast: cr/uncr bias depends on contrast sign,
        %with disparity-size correlation and more cells at small
        %disparities
        [cs_model_disparity_tunings,cs_model_disparity_maxs,cs_model_disparity_maxamps] = ...
            make_model_responses(width_law_ds_correlation,bias_contrast_simple,cell_number_dec);

        
    end

    function [model_disparity_tunings,model_disparity_maxs,model_disparity_maxamps] = ...
            make_model_responses(model_width_law,model_bias,cell_number)
        
        for c = 1 : length(contrasts)
            for k = 1 : length( disparities )
                
                sigma_k = model_width_law( c, k );
                bias = model_bias( c, k ) .* cell_number( c, k );
                
                population_k = bias * exp( -1/2 * ( ( disparity_axis - disparities_all( c, k ) * ones( size(disparity_axis) ) ) / sigma_k ) .^2 );
                
                %include negative component
                if gabor_modeling
                    population_k = population_k .* ( cos( 2 * pi / ( 4 * sigma_k ) * ( disparity_axis - disparities_all( c, k ) ) ));
                end
                
                % Allow a more important number of population centred on zero
                %     if abs( repartition_law( k ) ) < 1
                %         population_k = population_k .* 1.4;
                %     end
                
                %if ( sum( population_k( 1 : disp_axis_lim ) ) && sum( population_k( disp_axis_lim + 1 : end ) ) )
                %    overlap( k ) = abs( sum( population_k( 1 : disp_lim ) ) - sum( population_k( disp_lim + 1 : end ) ) );
                %else
                %    overlap( k ) = 0;
                %end
                
                model_disparity_tunings( c, k, :) = population_k;
                model_disparity_maxs( c, k) = max(disparity_axis(population_k == max(population_k)));
                model_disparity_maxamps( c, k) = max(population_k);

            end
        end
    end
        
        
    function [response,response_peak_disparity] = population_response(whichmodel,model_disparity_tunings)
        
        if whichmodel == 1
            im = im1;
            disp = disp1;    
        elseif whichmodel == 2
            im = im2;
            disp = disp2;
        end
        
        imsize = size(im);
        meanlum = mean(im(:));
        
        for p = 1:numel(im)
            
            c = (im(p) - meanlum)/(im(p) + meanlum);
            if im(p) == 0 & meanlum == 0
                c = 0;
            end
            c_delta = abs(contrasts - c);
            c_round = contrasts(max(find(c_delta == min(c_delta))));
            d = disp(p);
            d_round = round(10*d)./10;
            
            for u = 1:length(disparities)
                response(p,u) = model_disparity_tunings(contrasts == c_round,u,disparity_axis == d_round);
            end
            
            %find the max of 1000 bootstrapped distributions
            bootmax = bootstrp(100,@max,response(p,:));
            %solve for disparity of that max
            for b = 1:length(bootmax);
                dispmax(b) = disparities(response(p,:) == bootmax(b));
            end
            response_peak_disparity(p) = mean(dispmax);
            %response_peak_disparity(p) = disparities(response(p,:) == max(response(p,:)));
        end
        
        %matrix of peak disparity response at each pixel
        response_peak_disparity = reshape(response_peak_disparity,size(im));
        
        response_all = sum(response,1);

    end

    function plot_population_responses(response1,response2)
        axes(popax); 
        h(1) = plot(disparities,sum(response1,1),'color','r','LineStyle','-','LineWidth',1.5); hold on;
        h(2) = plot(disparities,sum(response2,1),'color','b','LineStyle','--','LineWidth',1.5);
        legend(h,'scenario 1','scenario 2');
        title('population responses');
        xlabel('disparity');
        ylabel('response amplitude (a.u.)');
        axis([-disp_axis_lim disp_axis_lim 1.1*min([sum(response1,1) sum(response2,1)]) 1.1*max([sum(response1,1) sum(response2,1)])])
        box on;
        hold off;
    end

    function plot_response_maps(response1_peak_disparity,response2_peak_disparity)
        axes(popax);
        response_im = [response1_peak_disparity response2_peak_disparity];
        imagesc(-response_im); hold on;
        rcb = colorbar;
        rectangle('Position',[1,1,size(response1_peak_disparity,1) - 1,size(response1_peak_disparity,1) - 1],'linestyle','-','edgecolor','r')
        rectangle('Position',[size(response2_peak_disparity,1) + 1,1,size(response2_peak_disparity,1) - 1,size(response2_peak_disparity,1) - 1],'linestyle','--','edgecolor','b')
        %title('population responses');
        %xlabel('disparity');
        %ylabel('response amplitude (a.u.)');
        %axis([-disp_axis_lim disp_axis_lim 1.1*min([sum(response1,1) sum(response2,1)]) 1.1*max([sum(response1,1) sum(response2,1)])])
        axis image off; box on;
        hold off;
        
    end

    function update_population_responses
        [response1,response1_peak_disparity] = population_response(1,model1_disparity_tunings);
        [response2,response2_peak_disparity] = population_response(2,model2_disparity_tunings);
        
        
        if show_response_map == 0
            plot_population_responses(response1,response2)
        elseif show_response_map == 1
            plot_response_maps(response1_peak_disparity,response2_peak_disparity)
        end
    end


end

