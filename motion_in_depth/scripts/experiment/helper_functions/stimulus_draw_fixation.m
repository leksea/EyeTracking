function stimulus_draw_fixation(w,scr,dat,stm,flipIt)
%
% draws binocular fixation nonius to the screen, if flipIt is 1, then draw
% full nonius and flip, if flipIt is 0, draw only verticals and wait to
% flip until the stimulus is drawn too


% length of diagonal lines
fixationRadiusXPix2 = sqrt(((stm.fixationRadiusXPix).^2)/2);
fixationRadiusYPix2 = sqrt(((stm.fixationRadiusYPix).^2)/2);

% line width in pixels
line_width  = 2;

% bg
Screen('FillRect', w, stm.glevel);

% central square - same size as dots
Screen('FillRect', w, stm.LEwhite, ...
	[scr.x_center_pix_left - stm.fixationDotRadiusPix ...
	scr.y_center_pix_left - stm.fixationDotRadiusPix ...
	scr.x_center_pix_left + stm.fixationDotRadiusPix ...
	scr.y_center_pix_left + stm.fixationDotRadiusPix] );

Screen('FillRect', w, stm.REwhite, ...
	[scr.x_center_pix_right - stm.fixationDotRadiusPix ...
	scr.y_center_pix_right - stm.fixationDotRadiusPix ...
	scr.x_center_pix_right + stm.fixationDotRadiusPix ...
	scr.y_center_pix_right + stm.fixationDotRadiusPix] );



% nonius lines


% vertical
if flipIt
	
	% make verticals the same as all other lines
	vertical_radius = stm.fixationRadiusYPix;
	vertical_width  = line_width;
	
else
	
	% make verticals the same as all other lines
	vertical_radius = stm.fixationRadiusYPix*2;
	vertical_width  = line_width*3;
	
end

% draw vertical lines
Screen('DrawLine', w, stm.REwhite, scr.x_center_pix_right, ...
	scr.y_center_pix_right  - (vertical_radius), ...
	scr.x_center_pix_right, ...
	scr.y_center_pix_right - (vertical_width) , vertical_width);

Screen('DrawLine', w, stm.LEwhite, scr.x_center_pix_left, ...
	scr.y_center_pix_left + (vertical_radius), ...
	scr.x_center_pix_left, ...
	scr.y_center_pix_left + (vertical_width), vertical_width);



% draw other lines and flip
if flipIt
	
	% horizontal
	Screen('DrawLine', w, stm.REwhite, scr.x_center_pix_right - (scr.signRight*stm.fixationRadiusXPix), ...
		scr.y_center_pix_right, ...
		scr.x_center_pix_right - (scr.signRight*stm.fixationDotRadiusPix + line_width), ...
		scr.y_center_pix_right , line_width);
	
	Screen('DrawLine', w, stm.LEwhite, scr.x_center_pix_left + (stm.fixationDotRadiusPix + line_width), ...
		scr.y_center_pix_left, ...
		scr.x_center_pix_left + (stm.fixationRadiusXPix), ...
		scr.y_center_pix_left, line_width);
	
	% diagonal
	Screen('DrawLine', w, stm.REwhite, scr.x_center_pix_right - (scr.signRight*fixationRadiusXPix2), ...
		scr.y_center_pix_right  - (scr.signRight*fixationRadiusYPix2), ...
		scr.x_center_pix_right + (scr.signRight*fixationRadiusXPix2), ...
		scr.y_center_pix_right  + (scr.signRight*fixationRadiusYPix2) , line_width);
	
	Screen('DrawLine', w, stm.REwhite, scr.x_center_pix_right - (scr.signRight*fixationRadiusXPix2), ...
		scr.y_center_pix_right  + (scr.signRight*fixationRadiusYPix2), ...
		scr.x_center_pix_right + (scr.signRight*fixationRadiusXPix2), ...
		scr.y_center_pix_right  - (scr.signRight*fixationRadiusYPix2) , line_width);
	
	Screen('DrawLine', w, stm.LEwhite, scr.x_center_pix_left - (fixationRadiusXPix2), ...
		scr.y_center_pix_left  - (fixationRadiusYPix2), ...
		scr.x_center_pix_left + (fixationRadiusXPix2), ...
		scr.y_center_pix_left  + (fixationRadiusYPix2) , line_width);
	
	Screen('DrawLine', w, stm.LEwhite, scr.x_center_pix_left - (fixationRadiusXPix2), ...
		scr.y_center_pix_left  + (fixationRadiusYPix2), ...
		scr.x_center_pix_left + (fixationRadiusXPix2), ...
		scr.y_center_pix_left  - (fixationRadiusYPix2) , line_width);
	
	Screen('Flip', w);
end

